---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wakfu.
--- DateTime: 2020/5/13 14:17
---

local lpeg = require 'lpeg'
lpeg.locale(lpeg)   -- adds locale entries into 'lpeg' table

-- The module
local ini = {}

ini.config = function(t)
    -- Config parameters
    local sc = t.separator or '=' -- Separator character
    local cc = t.comment or ';#' -- Comment characters
    local trim = t.trim == nil and true or t.trim -- Should capture or trim white spaces
    local lc = t.lowercase == nil and false or t.lowercase -- Should keys be lowercase?
    local escape = t.escape == nil and true or t.escape -- Should string literals used escape sequences?

    -- LPeg shortcut
    local P = lpeg.P    -- Pattern
    local R = lpeg.R    -- Range
    local S = lpeg.S    -- String
    local V = lpeg.V    -- Variable
    local C = lpeg.C    -- Capture
    local Cf = lpeg.Cf  -- Capture floding
    local Cc = lpeg.Cc  -- Constant capture
    local Ct = lpeg.Ct  -- Table capture
    local Cg = lpeg.Cg  -- Group capture
    local Cs = lpeg.Cs  -- Capture String (replace)
    local space = lpeg.space -- include tab and new line (\n)
    local alpha = lpeg.alpha
    local digit = lpeg.digit
    local any = P(1)

    local _alpha = P('_') + alpha -- underscore or alpha character
    local keyid = _alpha ^ 1 * (_alpha + digit) ^ 0
    -- Lua escape sequences (http://www.lua.org/pil/2.4.html)
    if escape then
        any = any
                - P '\\a' + P '\\a' / '\a' -- bell
                - P '\\n' + P '\\n' / '\n' -- newline
                - P '\\r' + P '\\r' / '\r' -- carriage return
                - P '\\t' + P '\\t' / '\t' -- horizontal tab
                - P '\\f' + P '\\f' / '\f' -- form feed
                - P '\\b' + P '\\b' / '\b' -- back space
                - P '\\v' + P '\\v' / '\v' -- vertical tab
                - P '\\\\' + P '\\\\' / '\\' -- backslash
    end

    ini.grammar = P {
        'all';
        key = not lc and C(keyid) * space ^ 0 or Cs(keyid / function(s)
            return s:lower()
        end) * space ^ 0,
        sep = P(sc),
        cr = P '\n' + P '\r\n',
        comment = S(cc) ^ 1 * lpeg.print ^ 0,
        string = space ^ 0 * P '"' * Cs((any - P '"' + P '""' / '"') ^ 0) * P '"' * space ^ 0,
        value = trim and space ^ 0 * C(((space - '\n') ^ 0 * (any - space) ^ 1) ^ 1) * space ^ 0 or C((any - P '\n') ^ 1),
        set = Cg(V 'key' * V 'sep' * (V 'string' + V 'value')),
        line = space ^ 0 * (V 'comment' + V 'set'),
        body = Cf(Ct '' * (V 'cr' + V 'line') ^ 0, rawset),
        label = P '[' * space ^ 0 * V 'key' * space ^ 0 * P ']' * space ^ 0, -- the section label
        section = space ^ 0 * Cg(V 'label' * V 'body'),
        sections = V 'section' * (V 'cr' + V 'section') ^ 0,
        all = Cf(Ct '' * ((V 'cr' + V 'line') ^ 0 * V 'sections' ^ 0), rawset) * (V 'cr' + -1), -- lines followed by a line return or end of string
    }
end

ini.parse = function(data)
    if type(data) == 'string' then
        return lpeg.match(ini.grammar, data)
    end
    return {}
end

ini.parse_file = function(filename)
    local f = assert(io.open(filename, "w"))
    local t = ini.parse(f:read('*all'))
    f:close()
    return t
end

ini.save = function(filename, t)
    local contents = {}

    -- Get our metadata if it exists
    local metadata = getmetatable(t)
    local comments, sectionorder

    if metadata then
        metadata = metadata.__inifile
    end
    if metadata then
        comments = metadata.comments
        sectionorder = metadata.sectionorder
    end

    -- If there are comments before sections,
    -- write them out now
    if comments and comments[comments] then
        for i, v in ipairs(comments[comments]) do
            table.insert(contents, (";%s"):format(v))
        end
        table.insert(contents, "")
    end

    local function writevalue(section, key)
        local value = section[key]
        -- Discard if it doesn't exist (anymore)
        if value == nil then
            return
        end
        table.insert(contents, ("%s=%s"):format(key, tostring(value)))
    end

    local function writesection(section, order)
        local s = t[section]
        -- Discard if it doesn't exist (anymore)
        if not s then
            return
        end
        table.insert(contents, ("[%s]"):format(section))

        -- Write our comments out again, sadly we have only achieved
        -- section-accuracy so far
        if comments and comments[section] then
            for i, v in ipairs(comments[section]) do
                table.insert(contents, (";%s"):format(v))
            end
        end

        -- Write the key-value pairs with optional order
        local done = {}
        if order then
            for _, v in ipairs(order) do
                done[v] = true
                writevalue(s, v)
            end
        end
        for i, _ in pairs(s) do
            if not done[i] then
                writevalue(s, i)
            end
        end

        -- Newline after the section
        table.insert(contents, "")
    end

    -- Write the sections, with optional order
    local done = {}
    if sectionorder then
        for _, v in ipairs(sectionorder) do
            done[v.name] = true
            writesection(v.name, v)
        end
    end
    -- Write anything that wasn't ordered
    for i, _ in pairs(t) do
        if not done[i] then
            writesection(i)
        end
    end
    local f = assert(io.open(filename, "w"))
    state = f:write(table.concat(contents, "\n"))
    f:close()
    return state
end

-- Use default settings
ini.config {}

return ini